# Performance Considerations

### [Big three for structs](http://www.somasim.com/blog/2015/08/c-performance-tips-for-unity-part-2-structs-and-enums/)
When implementing custom structs do these three things to avoid slow
garbage-generating iterations or Dictionary use:

* provide a type-specific equality comparison function via `IEquatable<T>`
* override `GetHashCode()` and `Equals()` with faster (custom) versions
* override operators `==` and `!=` to use strongly typed equality checks

### [Implement `IEqualityComparer<T>` for enum keys](http://www.somasim.com/blog/2015/08/c-performance-tips-for-unity-part-2-structs-and-enums/)
* Implement `IEqualityComparer<T>` for the enum type and pass that into the Dictionary constructor to avoid boxing.
* OR cast enums into ints and use an int-keyed dictionary.

### [Avoid UnityEvent from code](https://jacksondunstan.com/articles/3335)
* UnityEvent creates more garbage than C# `event` so only use when exposing through the inspector.


### [Unity Function Performance](https://jacksondunstan.com/articles/3605)
TODO: Rerun this test with nonempty functions.


### [Garbage generated by iteration](https://jacksondunstan.com/articles/3805)
* Iterating over arrays and `List<T>` produce no garbage.
* Iterating over `Dictionary<T>`, `HashSet<T>`, `LinkedList<T>`.
* `Dictionary<T>`, `HashSet<T>`, `LinkedList<T>`, `Queue<T>`, and `Stack<T>` only create garbage on the first iteration of each type T (not per-object).

